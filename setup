#!/bin/bash
#
# Small script that sets the stage for
# building this Docker image.

#######################################
# Usage string for the program.
# Globals:
#   PROGRAM_NAME
# Outputs:
#   - usage heredoc string to stdout
# Returns:
#   0 - cat success
#   1 - cat error
#######################################
usage () {
	cat << _EOF_
Usage: $PROGRAM_NAME [-c] [-h]

Description: Creates/pulls the needed material to perform a docker build. 

Options:
	-c	clean PWD of contents created from previous setup call
	-h	display usage str and exit

_EOF_
	return
}

#######################################
# Clean contents in PWD created from
# the JCASC_UTIL_FILENAME.
# Globals:
#   LOCAL_CASC_JENKINS_CONFIG_FILENAME
#	JCASC_UTIL_FILENAME
# Outputs:
#   - usage heredoc string to stdout
# Returns:
#   0 - JCASC_UTIL_FILENAME clean success
#   1 - JCASC_UTIL_FILENAME clean error
#######################################
clean () {
	if [ -f "$LOCAL_CASC_JENKINS_CONFIG_FILENAME" ]; then
    	rm --force "$LOCAL_CASC_JENKINS_CONFIG_FILENAME"
	fi
	"$JCASC_UTIL_FILENAME" setup --clean
	return
}

set -e
PROGRAM_NAME=$(basename "$0")
JCASC_UTIL_FILENAME="jcasc.py"
# NOTE: LOCAL_CASC_JENKINS_CONFIG_FILENAME should match 
# the same named ENV var in the 'Dockerfile', the file will COPY'ed 
# into the new image!
LOCAL_CASC_JENKINS_CONFIG_FILENAME="casc.yaml"
CHILD_SPECFIC_CASC_FILENAME="child-casc.yaml"
TEMP_CASC_FILENAME="temp-casc.yaml"

# NOTE: opt is unset incase it has been defined previously;
# getops will place the next option (e.g. o, t) into name;
unset opt
while getopts "hc" opt; do
	case "$opt" in
	# -c is for 'clean'
	"c")    CLEAN="true"
			;;
	"h")	usage
			exit 0
			;;
	":")    echo "${PROGRAM_NAME}: an argument is required for -- $OPTARG"
			exit 1
			;;
    *)		# NOTE: using the program with no arguments will cause '?'
			# to be inserted into $opt. However, I've found getopts seems to
			# handle unknown options (at least those not found in the opt str).
			# 'shellcheck' seems to say otherwise, and that a default case is needed.
			usage
			exit 1
			;;
    esac
done

if [ -z "$(which "$JCASC_UTIL_FILENAME")" ]; then
	echo "${PROGRAM_NAME}: ${JCASC_UTIL_FILENAME} cannot be found on the PATH!"
	exit 1
fi

if [ -n "$CLEAN" ]; then
	clean
	# return clean exit code
	exit
fi

"$JCASC_UTIL_FILENAME" setup
"$JCASC_UTIL_FILENAME" addjobs --transform-rffw --merge-yaml "./$CHILD_SPECFIC_CASC_FILENAME" > "$TEMP_CASC_FILENAME"
"$JCASC_UTIL_FILENAME" addagent-placeholder --numagents 1 --casc-path "$TEMP_CASC_FILENAME" > "$LOCAL_CASC_JENKINS_CONFIG_FILENAME"

rm --force "$TEMP_CASC_FILENAME"

exit 0
